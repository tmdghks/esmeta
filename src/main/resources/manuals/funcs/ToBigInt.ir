def ToBigInt(
  argument: ESValue,
): Normal[BigInt] | Abrupt[throw] = {
  call %0 = clo<"ToPrimitive">(argument, ~number~)
  assert (? %0: Completion)
  if (? %0: Abrupt) return %0
  else %0 = %0.Value
  let prim = %0
  if (= (typeof prim) @Undefined) {
    call %1 = clo<"__NEW_ERROR_OBJ__">("%TypeError.prototype%")
    call %2 = clo<"ThrowCompletion">(%1)
    return %2
  }
  if (= (typeof prim) @Null) {
    call %3 = clo<"__NEW_ERROR_OBJ__">("%TypeError.prototype%")
    call %4 = clo<"ThrowCompletion">(%3)
    return %4
  }
  if (= (typeof prim) @Boolean) {
    if prim return 1n else return 0n
  }
  if (= (typeof prim) @BigInt) return prim
  if (= (typeof prim) @Number) {
    call %5 = clo<"__NEW_ERROR_OBJ__">("%TypeError.prototype%")
    call %6 = clo<"ThrowCompletion">(%5)
    return %6
  }
  if (= (typeof prim) @String) {
    call %7 = clo<"StringToBigInt">(prim)
    let n = %7
    if (= n undefined) {
      call %8 = clo<"__NEW_ERROR_OBJ__">("%SyntaxError.prototype%")
      call %9 = clo<"ThrowCompletion">(%8)
      return %9
    }
    return n
  }
  if (= (typeof prim) @Symbol) {
    call %10 = clo<"__NEW_ERROR_OBJ__">("%TypeError.prototype%")
    call %11 = clo<"ThrowCompletion">(%10)
    return %11
  }
  assert false
}
